// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2811.RecycleRush.subsystems;

import org.usfirst.frc2811.RecycleRush.Robot;
import org.usfirst.frc2811.RecycleRush.RobotMap;
import org.usfirst.frc2811.RecycleRush.commands.*;

import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.CANJaguar.ControlMode;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.CANTalon;


/**
 *  Wraps the CAN Talon classes with helper functions and conversions to common units. 
 *  /For individual declarations, extend this class and add additional sensors and sensor reading functions
 *  //NOTE
 */
public class TalonSRXPIDBase extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    protected CANTalon motor;
    protected String name;
    protected void useMotor(CANTalon newMotor){
    	motor=newMotor;
    	name=motor.getDescription().toUpperCase();
    }
        
	double TOTEHEIGHT = 12;

    protected double setpoint;
    
    //Will be used internally, but can be overridden in the inherited class
    //These are not static since they will change once when the function is homed after initialization
    
    protected static double ENCODER_TICKS_FWD=100;
    protected static double ENCODER_TICKS_REV=-100;
    protected static double ENCODER_TICKS_INDEX;
    protected static double ENCODER_TICKS_HEIGHT=ENCODER_TICKS_FWD-ENCODER_TICKS_REV; 

    //For the mapping functions, these will be used to convert to inches
    //Using 0/100 is consistent for %, so let's use that as a default
    protected double INCHES_FWD=100;
    protected double INCHES_REV=0;
    protected double INCHES_INDEX=INCHES_REV;
    
    //This should be in inches
    protected double VIRTUAL_STOP_FWD=INCHES_FWD;
    protected double VIRTUAL_STOP_REV=INCHES_REV;
    
    //Constants for the Set function to indicate go up or down one tote
    public final static double GO_ONE_TOTE_UP=100;
    public final static double GO_ONE_TOTE_DOWN=-1;
    protected static double totePosition=0;

    protected boolean isHomed = false;
    
    /**
     * 
     * @param fwd_inches Motor Forward height in inches
     * @param rev_inches Motor Reverse height in inches
     * @param fwd_ticks Motor forward height in inches (relative)
     * @param rev_ticks Motor Reverse height in inches (relative)
     */
    public void setRange(double fwd_inches,double rev_inches,double fwd_ticks, double rev_ticks){
    	INCHES_FWD=fwd_inches;
    	INCHES_REV=rev_inches;
        ENCODER_TICKS_FWD=fwd_ticks;
        ENCODER_TICKS_REV=rev_ticks;

    	
    	ENCODER_TICKS_HEIGHT=fwd_ticks-rev_ticks;
    	Robot.logger.channel(name,"Talon height set to "+ENCODER_TICKS_HEIGHT+" ticks");
    }
    //*/
       
    /**
     * Set up virtual stops for when the robot is done homing
     * Units should be in inches
     * @param fwd (Units: Inches)
     * @param rev (Units: Inches)
     */
    public void setVirtualStops(double fwd,double rev){
    	VIRTUAL_STOP_FWD=fwd;
    	VIRTUAL_STOP_REV=rev;
    }
    /**
     * Write virtual stops to motor
     * Requires VIRTUAL_STOP_FWD and VIRTUAL_STOP_REV to be set
     */
    private void writeVirtualStops(){
    	double ticksFWD= map(VIRTUAL_STOP_FWD,INCHES_FWD,INCHES_REV,ENCODER_TICKS_FWD,ENCODER_TICKS_REV);
    	double ticksREV= map(VIRTUAL_STOP_REV,INCHES_FWD,INCHES_REV,ENCODER_TICKS_FWD,ENCODER_TICKS_REV);
    	
    	motor.enableForwardSoftLimit(true);
    	motor.enableReverseSoftLimit(true);
    	motor.setForwardSoftLimit((int) ticksFWD);
    	motor.setReverseSoftLimit((int) ticksREV);
    	Robot.logger.channel(name,"Virtual Limits set to "+ENCODER_TICKS_FWD+"in ("+ENCODER_TICKS_FWD+" ticks) " +ENCODER_TICKS_FWD+"in ("+"ENCODER_TICKS_REV"+"ticks)");
	}
    
    /**
     * Run homing sequence for robot using a default speed
     */
    public void home(){
    	home(-2);
    }
    
    /**
     * Home the motor in a specific direction
     * @param Raw motor value. Reverses itself if ReverseOutput is set, so the motor voltage is never affected by ReverseOutput 
     */
    public void home(double voltage){
    	//Run open loop to avoid direction reversals and other pitfalls.
    	motor.changeControlMode(CANTalon.ControlMode.Voltage);
	
    	if(isHomed){
    		//Do nothing for this block; Already homed, no need to panic, move, or print anything
    	}
    	else if(motor.isFwdLimitSwitchClosed()){
			Robot.logger.channel(name,"Forward Limit Switch hit: Reverse voltage, rehome");
			Robot.logger.error("LIMIT SWITCHES REVERSED OR WRONG HOMING VALUE");
		}
		else if(motor.isRevLimitSwitchClosed()){
			isHomed=true;
			Robot.logger.channel(name,"successfully homed");
		}
		else{ 
			/*TODO: This might be helpful for declaring a max value, and passing it as an argument to home();
			//However, it requires additional testing, since reverseInput(true) is non-detectable, and will reverse  the sign of speed();
			double velocity=0.02;
			double velocity_actual=speed();
			if(velocity_actual<velocity){
				//speed too slow, increase the output voltage in the appropriate direction
				voltage=motor.getOutputVoltage();
				voltage=voltage+Math.signum(voltage)*.01;
			}
			else if(velocity_actual>velocity){
				//speed too fast, increase the output voltage in the appropriate direction
				voltage=motor.getOutputVoltage();
				voltage=voltage-Math.signum(voltage)*.01;
			}
			//*/
			
			//Set motor moving in the proper direction.
			motor.set(voltage);
		}
	
		if(isHomed){	
			//Set default values now that we are at a known position
    		totePosition=0;
    	    ENCODER_TICKS_REV=motor.getEncPosition();
    	    ENCODER_TICKS_FWD=ENCODER_TICKS_REV+ENCODER_TICKS_HEIGHT;
    	    //writeVirtualStops(); //FIXME enable virtual stops
        	
        	//Put our motor back into the proper PID control mode
    		motor.changeControlMode(CANTalon.ControlMode.Position);
    	}

    }
    
    public void  printStatus(){
    	//Robot.logger.channel(name,"Forward Limits: "+INCHES_FWD+ "\t (ticks: "+ENCODER_TICKS_FWD+")");
    	//Robot.logger.channel(name,"Rev Limits    : "+INCHES_REV+ "\t (ticks: "+ENCODER_TICKS_REV+")");
    	//Robot.logger.channel(name,"Current State(IN) : Target:"+onTarget()+"\tH:"+get());
    	//Robot.logger.channel(name,"Current State(ticks) : Target:"+onTarget()+ "\tCurrent"+ getRawEncoder() +"\tTarget:"+setpoint);
    	//Robot.logger.channel(name,"Homing Status : " +isHomed+" Switch:"+isReverseSwitchPressed(false));
    	
    	//TODO: Make this a raw print statement, or tie in with the name variable
    	Robot.logger.channel(name,"CUR (H["+isHomed+","+isReverseSwitchPressed(false)+isForwardSwitchPressed(false)+"]), (in["+get()+"],t["+getRawEncoder()+"]), limits(in["+INCHES_FWD+","+INCHES_REV+"],t["+ENCODER_TICKS_FWD+","+ENCODER_TICKS_REV+"])"+" S[in("+setpoint+"),t("+motor.getSetpoint()+")]");

    }

    public boolean isHomed(){
    	return isHomed; //TODO: Make the return function meaningful
    }
    
    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
    	// Override this with your own code in the extended class

    	//To avoid random compiler issues, just write out to a dummy talon.
    	//Since address 0 is the PDP, this should not cause issues
    	motor=new CANTalon(0);
    	
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }
        
    /**
     * Get the velocity of the system
     * @return speed in inches per second
     */
    public double speed(){
    	double speed = motor.getSpeed(); // gives speed  in the sensor's native ticks per 100ms
    	
    	//convert ticks/100ms to inches/100ms
    	speed=map(speed,ENCODER_TICKS_FWD,ENCODER_TICKS_REV,INCHES_FWD,INCHES_REV);

    	//convert inches/100ms to inches/second 
    	speed=speed*10;
    	
      	return speed;
    }

    public void down(){
    	if(motor.isFwdLimitSwitchClosed() ){
    		//motor.ClearIaccum();
    	}
    	if(motor.isRevLimitSwitchClosed() ){
    		stop();
    	} else {
    		setpoint = motor.getPosition()-50;//TODO tune this
    		motor.set(setpoint);
    	}

    	//Correct tote position when moving manually
    	totePosition=Math.floor(get()/TOTEHEIGHT);

    }
    
    public void up(){
    	//prevent I hangups when coming off of a switch
    	if(motor.isRevLimitSwitchClosed() ){
        	//motor.ClearIaccum();
    	}
    	
    	//prevent I buildup when hitting a switch
    	if(motor.isFwdLimitSwitchClosed() ){
    		stop();
    	} else {
    	setpoint = motor.getPosition()+25;//TODO tune this
    	motor.set(setpoint);
    	}
    	
    	//Correct tote position when moving manually
    	totePosition=Math.floor(get()/TOTEHEIGHT);
    	
    }
    public void stop(){
    	setpoint=motor.getEncPosition();
    	motor.set(setpoint);
    	motor.ClearIaccum();
    	Robot.logger.channel(name,"Talon Stopped");
    }    
    
    public double get(){
    	//return current bident height in inches
    	double input;
    	double output;
    	input=motor.getPosition();
    	output = map(input,ENCODER_TICKS_FWD,ENCODER_TICKS_REV,INCHES_FWD,INCHES_REV);
    	return output;
    }
        
    public double set(double inches){
    	//todo: Should we use this?
    	//totePosition=Math.floorDiv((int)inches,(int) TOTEHEIGHT);
    	
    	//Convert to ticks and write to the motor
    	setpoint= map(inches,INCHES_FWD,INCHES_REV,ENCODER_TICKS_FWD,ENCODER_TICKS_REV); //TODO do a motor write
    	motor.set(setpoint);
    	return setpoint;
    } 
    
    /**
     * Returns true if the PID is within 1 inch of the desired setpoint
     * @return
     */

    public boolean onTarget(){
    	return onTarget(1);
    }
    
    /**
     * Returns true if the PID is within tolerance of the setpoint
     * @param tolerance : Error margin in inches for the function to be considered on target.
     * @return
     */
    public boolean onTarget(double tolerance){
    	//find out where we are
    	//find out where we want to go
    	//find the absolute value of the difference
    	// if it is less than 50, return true 
    	// of it is greater than 50, return false
	    double position =motor.getPosition();
	    double difference = Math.abs(setpoint - position);
	
	    difference=Math.abs(map(difference,ENCODER_TICKS_FWD,ENCODER_TICKS_REV,INCHES_FWD,INCHES_REV));
	    //System.out.println("S: "+setpoint+" P: "+position+ "D:"+difference +" S?" +isIndexSwitchPressed());
	    
		if (difference<=tolerance){
			return true;
			}
		else {
			return false;
		}
    }
    
    public double getTotes(){
    	return totePosition;    	
    }
    
	/**
	 * 
	 * @param toteheight
	 */
    public void setTotes(double toteheight){
    	//Set the pid to a specific height in totes
    	//TODO set tote height
		double GAP = 6;
		if(toteheight < 0){
			toteheight = 0;
		}
		if(toteheight > 6){
			toteheight = 6;
		}
		totePosition=toteheight;
        set( toteheight*TOTEHEIGHT-GAP);
        
    }

    public void setOneToteUp(){
		double GAP = 6;
		double GRAB = -6;
    	//Set the pid to a specific height in totes
    	//TODO set tote height
		totePosition=(getTotes()+1);
		if(totePosition > 6){
			totePosition = 6;
		}		
;        set( totePosition*TOTEHEIGHT+GAP);

    }
    public void setOneToteDown(){
    	double GAP = 6;
    	double GRAB = -6;
    	totePosition=(getTotes()-1);
    	if(totePosition < 0){
			totePosition = 0;
		}
    	set( totePosition*TOTEHEIGHT+GAP);
    }
    
    
    public boolean isIndexSwitchPressed(){
    	//Switch is normally high (1), and low(0) when closed
    	return motor.getPinStateQuadIdx()==1?false:true;
    }
    
    /**
     * Return Switch state, with ability to disable soft limits
     * @param enableSoftLimits
     * @return
     */
    public boolean isForwardSwitchPressed(boolean enableSoftLimits){
    	//Switch is normally high (1), and low(0) when closed
    	if(enableSoftLimits==true){
    		return isForwardSwitchPressed();
    	}
    	else return motor.isFwdLimitSwitchClosed();
    }

    /**
     * Returns switch state
     * @return true if switch is pressed, or if virtual limits exceeded
     */
    public boolean isForwardSwitchPressed(){
    	if(get()>=VIRTUAL_STOP_FWD){
    		return true;
    	}
    	//Switch is normally high (1), and low(0) when closed
    	return motor.isFwdLimitSwitchClosed();//==1?false:true;
    }

    /**
     * Return Switch state, with ability to disable soft limits
     * @param enableSoftLimits
     * @return
     */
    public boolean isReverseSwitchPressed(boolean enableSoftLimits){
    	//Switch is normally high (1), and low(0) when closed
    	if(enableSoftLimits==true){
    		return isReverseSwitchPressed();
    	}
    	else return motor.isRevLimitSwitchClosed();
    }
    
    /**
     * Returns switch state
     * @return true if switch is pressed, or if virtual limits exceeded
     */
    public boolean isReverseSwitchPressed(){
    	if(get()<=VIRTUAL_STOP_REV){
    		return true;
    	}
    	return isReverseSwitchPressed();
    }

    public double getRawEncoder(){
    	return motor.getEncPosition() ;
    	
    }
    
    public void disable(){
    	//FIXME: Disable/enable doesn't work
    	//private edu.wpi.first.wpilibj.CANTalon.ControlMode previous_motor_state=motor.getControlMode();
		motor.changeControlMode(CANTalon.ControlMode.Disabled);
    	Robot.logger.channel(name,"Talon control disabled");
    }
    
    public void enable(){
    	//FIXME: Disable/enable doesn't work
    	//TODO: Make this save the previous control mode
		motor.changeControlMode(CANTalon.ControlMode.Position);
		stop();
    	Robot.logger.channel(name,"Talon control enabled");

    }

protected double map( double input, double maximum, double minimum, double outputMax, double outputMin){
	double output = (input/(maximum-minimum)-minimum/(maximum-minimum))*(outputMax-outputMin)+outputMin;
	if (output==Double.NaN){
		//System.out.println("Map::Error::"+input+"  "+minimum+"  "+maximum+"  "+outputMin+"  "+outputMax);
		output=minimum;
		}
	return output; 
	//NO ONE EXPECTS THE SPANISH INQUISITION
	}
}
           
    	
    
	
	
		
	
    
    


