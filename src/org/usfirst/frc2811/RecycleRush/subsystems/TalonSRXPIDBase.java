// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2811.RecycleRush.subsystems;

import org.usfirst.frc2811.RecycleRush.Robot;
import org.usfirst.frc2811.RecycleRush.RobotMap;
import org.usfirst.frc2811.RecycleRush.commands.*;

import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.CANJaguar.ControlMode;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.CANTalon;


/**
 *  This contains the common functions for the two Lifer systems. 
 *  /For individual declarations, extend this class
 *  //NOTE
 */
public class TalonSRXPIDBase extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    protected CANTalon motor;
    protected void useMotor(CANTalon newMotor){
    	motor=newMotor;
    }
        
    protected double setpoint;
    
    //Will be used internally, but can be overridden in the inherited class
    //These are not static since they will change once when the function is homed after initialization
    
    protected static double ENCODER_TICKS_FWD=100;
    protected static double ENCODER_TICKS_REV=-100;
    protected static double ENCODER_TICKS_INDEX;
    protected static double ENCODER_TICKS_HEIGHT=ENCODER_TICKS_FWD-ENCODER_TICKS_REV; 

    //For the mapping functions, these will be used to convert to inches
    //Using 0/100 is consistent for %, so let's use that as a default
    protected double INCHES_FWD=100;
    protected double INCHES_REV=0;
    protected double INCHES_INDEX=INCHES_REV;
    
    //This should be in inches
    protected double VIRTUAL_STOP_FWD=INCHES_FWD;
    protected double VIRTUAL_STOP_REV=INCHES_REV;
    
    //Constants for the Set function to indicate go up or down one tote
    public final static double GO_ONE_TOTE_UP=100;
    public final static double GO_ONE_TOTE_DOWN=-1;

    protected boolean isHomed = false;
    
    /**
     * Set the height of the system in inches
     * This is used for internal mapping to provide accurate results
     * @param fwd
     * @param rev
     */
    public void setRangeInInches(double fwd,double rev){
    	INCHES_FWD=fwd;
    	INCHES_REV=rev;
    }
    
    /**
     * Set the height of the system in encoder ticks. 
     * This should be consistent barring hardware changes
     * @param ticks
     */
    public void setHeightInTicks(double ticks){
    	ENCODER_TICKS_HEIGHT=ticks;
    }
    
    /**
     * Save some math, and provide 2 ticks for the end stop of the ticks
     * @param ticksFwd Number of ticks for the FWD direction of the robot
     * @param ticksRev Number of ticks for the REV direction of the robot
     */
    public void setHeightInTicks(double ticksFwd,double ticksRev){
    	setHeightInTicks(ticksFwd-ticksRev);
    }
       
    /**
     * Set up virtual stops for when the robot is done homing
     * Units should be in inches
     * @param fwd (Units: Inches)
     * @param rev (Units: Inches)
     */
    public void setVirtualStops(double fwd,double rev){
    	VIRTUAL_STOP_FWD=fwd;
    	VIRTUAL_STOP_REV=rev;
    }
    /**
     * Write virtual stops to motor
     * Requires VIRTUAL_STOP_FWD and VIRTUAL_STOP_REV to be set
     */
    private void writeVirtualStops(){
    	double ticksFWD= Map(VIRTUAL_STOP_FWD,INCHES_FWD,INCHES_REV,ENCODER_TICKS_FWD,ENCODER_TICKS_REV);
    	
    	motor.enableForwardSoftLimit(true);
    	motor.enableReverseSoftLimit(true);
    	motor.setForwardSoftLimit((int) ENCODER_TICKS_FWD);
    	motor.setReverseSoftLimit((int) ENCODER_TICKS_REV);
    	}
    
    /**
     * 
     */
    public void Home(){
    	Down(); // Additional check for switch
    	if (motor.isRevLimitSwitchClosed()){
    		isHomed = true ;
    	    ENCODER_TICKS_REV=motor.getEncPosition();
    	    ENCODER_TICKS_FWD=ENCODER_TICKS_REV+ENCODER_TICKS_HEIGHT;
    	    writeVirtualStops();
    	}
    	
    }
    
    public void  printStatus(){
    	System.out.println("Forward Limits: "+INCHES_FWD+ "\t (ticks: "+ENCODER_TICKS_FWD+")");
    	System.out.println("Rev Limits    : "+INCHES_REV+ "\t (ticks: "+ENCODER_TICKS_REV+")");
    	System.out.println("Current State(IN) : Target:"+onTarget()+"\tH:"+get());
    	System.out.println("Current State(ticks) : Target:"+onTarget()+ "\tCurrent"+ getRawEncoder() +"\tTarget:"+setpoint);
    	System.out.println("Homing Status : " +isHomed+" Switch:"+isReverseSwitchPressed());

    }

    public boolean isHomed(){
    	return isHomed; //TODO: Make the return function meaningful
    }
    
    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
    	// Override this with your own code in the extended class

    	//To avoid random compiler issues, just write out to a dummy talon.
    	//Since address 0 is the PDP, this should not cause issues
    	motor=new CANTalon(0);
    	
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }
        
    public double Speed(){
    	double speed = motor.getSpeed(); // gives speed  in the sensor's native ticks per 100ms
      	return speed;
    }

    public void Down(){
    	if(motor.isFwdLimitSwitchClosed() ){
    		//motor.ClearIaccum();
    	}
    	if(motor.isRevLimitSwitchClosed() ){
    		stop();
    	} else {
    		setpoint = motor.getPosition()-25;//TODO tune this
    		motor.set(setpoint);
    	}
    }
    
    public void Up(){
    	//prevent I hangups when coming off of a switch
    	if(motor.isRevLimitSwitchClosed() ){
        	//motor.ClearIaccum();
    	}
    	
    	//prevent I buildup when hitting a switch
    	if(motor.isFwdLimitSwitchClosed() ){
    		stop();
    	} else {
    	setpoint = motor.getPosition()+25;//TODO tune this
    	motor.set(setpoint);
    	}
    }
    public void stop(){
    	setpoint=motor.getPosition();
    	motor.ClearIaccum();
    }    
    
    public double get(){
    	//return current bident height in inches
    	double input;
    	double output;
    	input=motor.getPosition();
    	output = Map(input,ENCODER_TICKS_FWD,ENCODER_TICKS_REV,INCHES_FWD,INCHES_REV);
    	return output;
    }
        
    public double set(double inches){
    	//needs to set the target for the pid controller on the srx
    	//expects inches
    	//setpoint=inches;
    	setpoint= Map(inches,INCHES_FWD,INCHES_REV,ENCODER_TICKS_FWD,ENCODER_TICKS_REV); //TODO do a motor write
    	motor.set(setpoint);
    	return setpoint;
    } 
    public boolean onTarget(){
    	//find out where we are
    	//find out where we want to go
    	//find the absolute value of the difference
    	// if it is less than 50, return true 
    	// of it is greater than 50, return false
	    double position =motor.getPosition();
	    double difference = Math.abs(setpoint - position);
	
	    //FIXME Don't need print spam unless debugging
	    //System.out.println("S: "+setpoint+" P: "+position+ "D:"+difference +" S?" +isIndexSwitchPressed());
		if (difference<=50){
			return true;
			}
			else {
				return false;
			}
    }

    public int getTotes(){
    	//return current bident height in totes
    	//TODO return bident height in totes
    	return 1;
    }
    
    public void setTotes(double toteheight){
    	//Set the pid to a specific height in totes
    	//TODO set tote height
    }

    public boolean isIndexSwitchPressed(){
    	//Switch is normally high (1), and low(0) when closed
    	return motor.getPinStateQuadIdx()==1?false:true;
    }
    public boolean isForwardSwitchPressed(){
    	if(get()>=VIRTUAL_STOP_FWD){
    		return true;
    	}
    	//Switch is normally high (1), and low(0) when closed
    	return motor.isFwdLimitSwitchClosed();//==1?false:true;
    }

    public boolean isReverseSwitchPressed(){
    	if(get()<=VIRTUAL_STOP_REV){
    		return true;
    	}
    	//Switch is normally high (1), and low(0) when closed
		return motor.isRevLimitSwitchClosed();
    }

    public double getRawEncoder(){
    	return motor.getEncPosition() ;
    	
    }

protected double Map( double input, double maximum, double minimum, double outputMax, double outputMin){
	double output = (input/(maximum-minimum)-minimum/(maximum-minimum))*(outputMax-outputMin)+outputMin;
	if (output==Double.NaN){
		//System.out.println("Map::Error::"+input+"  "+minimum+"  "+maximum+"  "+outputMin+"  "+outputMax);
		output=minimum;
		}
	return output; 
	//NO ONE EXPECTS THE SPANISH INQUISITION
	}
}
           
    	
    
	
	
		
	
    
    


