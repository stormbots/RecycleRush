// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2811.RecycleRush.subsystems;

import org.usfirst.frc2811.RecycleRush.RobotMap;
import org.usfirst.frc2811.RecycleRush.commands.*;

import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.CANJaguar.ControlMode;
import edu.wpi.first.wpilibj.command.Subsystem;


/**
 *
 */
public class Bident extends TalonSRXPIDBase {
    
	private static Solenoid bidentSolenoidA = new Solenoid(0);
	private static Solenoid bidentSolenoidB = new Solenoid(1);
    public boolean open = false;
    public boolean closed = !open;
    public boolean bidentState = closed;
    private Ultrasonic bidentSonarIntake = new Ultrasonic(10,11);
    private Ultrasonic bidentSonarBumper = new Ultrasonic(2,3);

	/**
	 * This is used to enable or disable the BidentMonitor command
	 * use enable() or disable() to set it. 
	 */
	private boolean heightMonitoringEnabled=true;
	
	
    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
    	//Don't use this: It requires requires(), which screws up other stuff
        //setDefaultCommand(new BidentMonitor());
    	
    	setName("Bident"); //declare the name used for printing in the TalonPIDBase
    	useMotor(new CANTalon(5)); //ensure that we're using the same TalonSRX for all Bident code
    	
    	talonSRX.setProfile(0);
    	talonSRX.changeControlMode(CANTalon.ControlMode.Speed);
    	talonSRX.set(0);
    	talonSRX.setPID(6, 0.01,0);
    	talonSRX.setVoltageRampRate(6);
    	talonSRX.setCloseLoopRampRate(0);
    	talonSRX.enableBrakeMode(false);
    	talonSRX.clearStickyFaults();
    	
    	/*TODO: Ensure these are always set, even if they're false
    	//We need to verify that they don't get locked in robot memory, causing random issues
    	//when switching robots. 
    	*/
    	
    	//WORKING, but switches reversed
    	//bident.reverseOutput(true);
    	//bident.reverseSensor(false);
    	//reverseMotorDirection(false);
  
    	//Same thing, but we reversed switches in hardware
    	talonSRX.reverseOutput(false);
    	talonSRX.reverseSensor(true);
    	reverseMotorDirection(true);
    	    	
    	setRange(10, 60, 0, 9000);
    	    	
    }
  
    
    /*
     * Configure some Tote handling functions
     */

	final double TOTEHEIGHT=12;
	final double idealTotePickupHeight=6;
	
    /**
     * Set the height to a particular tote, with tote to pick up, with 1 being the lowest tote
     * @param TotePosition: 
     */
    public void setTotePosition(double TotePosition){
    	TotePosition=constrain(TotePosition,1,6);
    	
    	/* 
    	 * This sets the height to the ideal spot on the particular tote. 
    	 * Eg, 6" centers it on the tote, but 9" puts it very close to the top lip
    	 */
    	double target=(TOTEHEIGHT-1)*TotePosition+idealTotePickupHeight;
    	setHeight( target );	
    }
    
    	
    /**
     * Considers each 12" zone a "tote", and returns the height of that tote
     * Eg: If the height is 12" or less, this will return 1;
     * @return
     */
    public double getTotePosition(){
    	return Math.ceil(getHeight()/TOTEHEIGHT);
    }
    
    /**
     * Go up 1 tote from the current position
     */
    public void goUpOneTote(){
    	setTotePosition(getTotePosition()+1);
    }
    
    /**
     * Go Down one tote from the current position
     */
    public void goDownOneTote(){
    	setTotePosition(getTotePosition()-1);
    }

    /**
     * Center the bident on the current tote.
     * Helpful for cleaning up after a manual move putting it in the ballpark
     */
    public void resetTotePosition(){
    	setTotePosition(getTotePosition());
    }
        
    public double getDistanceTop(){
    	double distance = 0;
    	//FIXME Does not return correctly. Returns void, kills robot
    	if(bidentSonarBumper.isRangeValid() && bidentSonarBumper.isEnabled()){
    		distance=   bidentSonarBumper.getRangeInches();
        } else if (bidentSonarBumper.isEnabled() == false) {
        	distance = -1;
        } else if (bidentSonarBumper.isRangeValid() == false) {
        	distance = -2;
        } else {
        	System.out.println("B0RK3D!!!1!");
        	distance = -3;
        }
    	return distance;
    }
    
    public double getDistanceBumper(){
    	double distance = 0;
    	//TODO calibrate range maybe...(limits)
        if(bidentSonarIntake.isRangeValid() && bidentSonarIntake.isEnabled()){
        	distance = bidentSonarIntake.getRangeInches();
        } else if (bidentSonarIntake.isEnabled() == false) {
        	//System.out.println("not enabled");
        	distance = -1;
        } else if (bidentSonarIntake.isRangeValid() == false) {
        	distance= -2;
        } else {
        	System.out.println("B0RK3D!!!1!");
        	distance = -3;
        }    	
        return distance;
    }
    
    public void open(){
    	bidentSolenoidA.set(open);
    	bidentSolenoidB.set(closed);
    }
    
    public void close(){
    	bidentSolenoidA.set(closed);
    	bidentSolenoidB.set(open);
    }    
    
    /*public boolean solenoidOpen(){
    	return bidentSolenoidA.get()==open?true:false;
    }*/
}

